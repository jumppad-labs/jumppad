// Code generated by mockery v2.53.0. DO NOT EDIT.

package mocks

import (
	shipyard "github.com/jumppad-labs/connector/protos/shipyard"
	types "github.com/jumppad-labs/jumppad/pkg/clients/connector/types"
	mock "github.com/stretchr/testify/mock"
)

// Connector is an autogenerated mock type for the Connector type
type Connector struct {
	mock.Mock
}

// ExposeService provides a mock function with given fields: name, port, remoteAddr, destAddr, direction
func (_m *Connector) ExposeService(name string, port int, remoteAddr string, destAddr string, direction string) (string, error) {
	ret := _m.Called(name, port, remoteAddr, destAddr, direction)

	if len(ret) == 0 {
		panic("no return value specified for ExposeService")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, string, string, string) (string, error)); ok {
		return rf(name, port, remoteAddr, destAddr, direction)
	}
	if rf, ok := ret.Get(0).(func(string, int, string, string, string) string); ok {
		r0 = rf(name, port, remoteAddr, destAddr, direction)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, int, string, string, string) error); ok {
		r1 = rf(name, port, remoteAddr, destAddr, direction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateLeafCert provides a mock function with given fields: privateKey, rootCA, hosts, ips, dir
func (_m *Connector) GenerateLeafCert(privateKey string, rootCA string, hosts []string, ips []string, dir string) (*types.CertBundle, error) {
	ret := _m.Called(privateKey, rootCA, hosts, ips, dir)

	if len(ret) == 0 {
		panic("no return value specified for GenerateLeafCert")
	}

	var r0 *types.CertBundle
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string, []string, string) (*types.CertBundle, error)); ok {
		return rf(privateKey, rootCA, hosts, ips, dir)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string, []string, string) *types.CertBundle); ok {
		r0 = rf(privateKey, rootCA, hosts, ips, dir)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CertBundle)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, []string, []string, string) error); ok {
		r1 = rf(privateKey, rootCA, hosts, ips, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateLocalCertBundle provides a mock function with given fields: out
func (_m *Connector) GenerateLocalCertBundle(out string) (*types.CertBundle, error) {
	ret := _m.Called(out)

	if len(ret) == 0 {
		panic("no return value specified for GenerateLocalCertBundle")
	}

	var r0 *types.CertBundle
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*types.CertBundle, error)); ok {
		return rf(out)
	}
	if rf, ok := ret.Get(0).(func(string) *types.CertBundle); ok {
		r0 = rf(out)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CertBundle)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(out)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLocalCertBundle provides a mock function with given fields: dir
func (_m *Connector) GetLocalCertBundle(dir string) (*types.CertBundle, error) {
	ret := _m.Called(dir)

	if len(ret) == 0 {
		panic("no return value specified for GetLocalCertBundle")
	}

	var r0 *types.CertBundle
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*types.CertBundle, error)); ok {
		return rf(dir)
	}
	if rf, ok := ret.Get(0).(func(string) *types.CertBundle); ok {
		r0 = rf(dir)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CertBundle)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsRunning provides a mock function with no fields
func (_m *Connector) IsRunning() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsRunning")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ListServices provides a mock function with no fields
func (_m *Connector) ListServices() ([]*shipyard.Service, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListServices")
	}

	var r0 []*shipyard.Service
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]*shipyard.Service, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*shipyard.Service); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*shipyard.Service)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveService provides a mock function with given fields: id
func (_m *Connector) RemoveService(id string) error {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveService")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Start provides a mock function with given fields: _a0
func (_m *Connector) Start(_a0 *types.CertBundle) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.CertBundle) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stop provides a mock function with no fields
func (_m *Connector) Stop() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewConnector creates a new instance of Connector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConnector(t interface {
	mock.TestingT
	Cleanup(func())
}) *Connector {
	mock := &Connector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
